##设计模式概述
设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。
- **模式名称(Pattern Name)** 通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名，微笑）
- **问题(Problem)** 描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因
- **解决方案(Solution)** 描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述
- **效果(Consequences)** 描述了模式的优缺点以及在使用模式时应权衡的问题

#####学习设计模式需要掌握的几点
1. 设计模式的意图是什么，主要解决一个什么问题，什么时候使用它
2. 掌握它的结构图，记住它的关键代码
3. 能够想到至少两个它的应用实例，一个生活中的，一个软件中的
4. 这个模式的优缺点是什么，在使用时要注意什么

###面向对象原则
面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一
- 单一职责原则：一个类只负责一个功能领域中的相应职责
- 开闭原则：软件实体应对扩展开放，而对修改关闭
  
  *即软件实体应尽量在不修改原有代码的情况下进行扩展。*————————抽象化是开闭原则的关键。

- 里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象
- 依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象
  
    依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。

    开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段

- 接口隔离原则：使用多个专门的接口，而不使用单一的总接口
- 合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的

    在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过**组合/聚合关系** 或**通过继承** ，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。
    继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类
    一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。
- 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用

    不要和“陌生人”说话、只与你的直接朋友通信
    在迪米特法则中，对于一个对象，其朋友包括以下几类：
  
      (1) 当前对象本身(this)；
  
      (2) 以参数形式传入到当前对象方法中的对象；
  
      (3) 当前对象的成员对象；
  
      (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
  
      (5) 当前对象所创建的对象。

***
##六个创建型模式

###1. 简单工厂模式

**问题描述** ：开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等

Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：

```
class Chart {
private String type; //图表类型
	public Chart(Object[][] data, String type) {
		this.type = type;
		if (type.equalsIgnoreCase("histogram")) {
			//初始化柱状图
		}
		else if (type.equalsIgnoreCase("pie")) {
			//初始化饼状图
		}
		else if (type.equalsIgnoreCase("line")) {
			//初始化折线图
		}
	}
	public void display() {
		if (this.type.equalsIgnoreCase("histogram")) {
			//显示柱状图
		}
		else if (this.type.equalsIgnoreCase("pie")) {
			//显示饼状图
		}
		else if (this.type.equalsIgnoreCase("line")) {
			//显示折线图
		}	
	}
```
问题：
    1. 包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大 
    2. 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。
    3. 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离
    4. 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，导致代码重复

**简单工厂模式** ：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。

- 具体产品类：需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类
- 抽象产品类：将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类
- 工厂类：用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图1所示：
![](img/sample_factory_1.jpg)

**简单工厂基本实现流程**
由上述例子，可以很容易总结出简单工厂的实现流程：

1. 设计一个抽象产品类，它包含一些公共方法的实现；

2. 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码；

3. 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称）创建不同的具体产品类对象；

4. 客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

[实现代码SampleFactory.cpp](sample_factory/SampleFactory.cpp)

`g++ SampleFactory.cpp -o main -std=c++11`


###2. 工厂方法模式

###3. 抽象工厂模式

