##博客
[史上最全设计模式导学目录（完整版）](https://blog.csdn.net/LoveLion/article/details/17517213)
[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)

##设计模式概述
设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。
- **模式名称(Pattern Name)** 通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名，微笑）
- **问题(Problem)** 描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因
- **解决方案(Solution)** 描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述
- **效果(Consequences)** 描述了模式的优缺点以及在使用模式时应权衡的问题

#####学习设计模式需要掌握的几点
1. 设计模式的意图是什么，主要解决一个什么问题，什么时候使用它
2. 掌握它的结构图，记住它的关键代码
3. 能够想到至少两个它的应用实例，一个生活中的，一个软件中的
4. 这个模式的优缺点是什么，在使用时要注意什么

###面向对象原则
面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一
- 单一职责原则：一个类只负责一个功能领域中的相应职责
- 开闭原则：软件实体应对扩展开放，而对修改关闭
  
  *即软件实体应尽量在不修改原有代码的情况下进行扩展。*————————抽象化是开闭原则的关键。

- 里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象
- 依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象
  
    依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。

    开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段

- 接口隔离原则：使用多个专门的接口，而不使用单一的总接口
- 合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的

    在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过**组合/聚合关系** 或**通过继承** ，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。
    继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类
    一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。
- 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用

    不要和“陌生人”说话、只与你的直接朋友通信
    在迪米特法则中，对于一个对象，其朋友包括以下几类：
  
      (1) 当前对象本身(this)；
  
      (2) 以参数形式传入到当前对象方法中的对象；
  
      (3) 当前对象的成员对象；
  
      (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
  
      (5) 当前对象所创建的对象。

***
##六个创建型模式

###1. 简单工厂模式

**问题描述** ：开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等

Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：

```
class Chart {
private String type; //图表类型
	public Chart(Object[][] data, String type) {
		this.type = type;
		if (type.equalsIgnoreCase("histogram")) {
			//初始化柱状图
		}
		else if (type.equalsIgnoreCase("pie")) {
			//初始化饼状图
		}
		else if (type.equalsIgnoreCase("line")) {
			//初始化折线图
		}
	}
	public void display() {
		if (this.type.equalsIgnoreCase("histogram")) {
			//显示柱状图
		}
		else if (this.type.equalsIgnoreCase("pie")) {
			//显示饼状图
		}
		else if (this.type.equalsIgnoreCase("line")) {
			//显示折线图
		}	
	}
```
问题：
    1. 包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大 
    2. 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。
    3. 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离
    4. 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，导致代码重复

**简单工厂模式** ：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。

- 具体产品类：需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类
- 抽象产品类：将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类
- 工厂类：用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图1所示：

![](img/sample_factory_1.jpg)

**简单工厂基本实现流程**
由上述例子，可以很容易总结出简单工厂的实现流程：

1. 设计一个抽象产品类，它包含一些公共方法的实现；

2. 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码；

3. 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称）创建不同的具体产品类对象；

4. 客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

[实现代码SampleFactory.cpp](sample_factory/SampleFactory.cpp)

`g++ SampleFactory.cpp -o main -std=c++11`

**简单工厂模式总结**

优点：工厂类提供创建具体产品的方法，并包含一定判断逻辑，客户不必参与产品的创建过程；
客户只需要知道对应产品的参数即可，参数一般简单好记，如数字、字符或者字符串等。

缺点：**违背了开闭原则（对扩展开放，对修改关闭），即在扩展功能时修改了既有的代码**

**方案的改进**

每更换一个Chart对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。

**适用场景**
在以下情况下可以考虑使用简单工厂模式：

    (1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
    
    (2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

###2. 工厂方法模式
工厂方法模式中不再使用工厂类统一创建所有的具体产品，而是针对不同的产品设计了不同的工厂，每一个工厂只生产特定的产品。

**定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。**

####工厂方法模式结构
**问题描述**    Sunny软件公司欲开发一个系统运行日志记录器(Logger)，该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是Sunny公司开发人员面临的一个难题。

从工厂方法模式简介中，可以知道该模式有以下几种角色：
- **抽象工厂（AbstractFactory）** ：所有生产具体产品的工厂类的基类，提供工厂类的公共方法；
- **具体工厂（ConcreteFactory）** :生产具体的产品
- **抽象产品（AbstractProduct）** :所有产品的基类，提供产品类的公共方法
- **具体产品（ConcreteProduct）** :具体的产品类
![](img/factory.jpg)
  
**完整解决方案**

Sunny公司开发人员决定使用工厂方法模式来设计日志记录器，其基本结构如图3所示：
![](img/factory_2.jpg)

在图中，Logger接口充当抽象产品，其子类FileLogger和DatabaseLogger充当具体产品，LoggerFactory接口充当抽象工厂，其子类FileLoggerFactory和DatabaseLoggerFactory充当具体工厂。完整代码如下所示：

[实现代码Factory.cpp](factory/Factory.cpp)

`g++ Factory.cpp -o main -std=c++11 -g`

####工厂方法模式总结
**优点** ：
- 工厂方法用于创建客户所需产品，同时向客户隐藏某个具体产品类将被实例化的细节，用户只需关心所需产品对应的工厂；
- 工厂自主决定创建何种产品，并且创建过程封装在具体工厂对象内部，多态性设计是工厂方法模式的关键；
- 新加入产品时，无需修改原有代码，增强了系统的可扩展性，符合开闭原则。

**缺点** :
- 添加新产品时需要同时添加新的产品工厂，系统中类的数量成对增加，增加了系统的复杂度，更多的类需要编译和运行，增加了系统的额外开销；
- 工厂和产品都引入了抽象层，客户端代码中均使用的抽象层（AbstractFactory和AbstractSportProduct ），增加了系统的抽象层次和理解难度。

**适用环境：**
- 客户端不需要知道它所需要创建的对象的类；
- 抽象工厂类通过其子类来指定创建哪个对象（运用多态性设计和里氏代换原则）


###3. 抽象工厂模式
抽象工厂模式，其抽象程度更高，每一个具体工厂可以生产一组相关的具体产品对象。

**抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。**

####抽象工厂模式结构
抽象工厂模式结构与工厂方法模式结构类似，不同之处在于，一个具体工厂可以生产多种同类相关的产品：
- **抽象工厂（AbstractFactory）**：所有生产具体产品的工厂类的基类，提供工厂类的公共方法；
- **具体工厂（ConcreteFactory）**：生产具体的产品
- **抽象产品（AbstractProduct）**：所有产品的基类，提供产品类的公共方法
- **具体产品（ConcreteProduct）**：具体的产品类

![](img/abstractFactory.png)

**问题描述**    Jungle想要进行户外运动，它可以选择打篮球和踢足球。但这次Jungle不想弄脏原本穿的T恤，所以Jungle还需要穿球衣，打篮球就穿篮球衣，踢足球就穿足球衣。篮球保管室可以提供篮球和篮球衣，足球保管室可以提供足球和足球衣。Jungle只要根据心情去某个保管室，就可以换上球衣、拿上球，然后就可以愉快地玩耍了。

![](img/abstractFactory_1.png)

[实现代码AbstractFactory.cpp](abstract_factory/AbstratFactory.cpp)

`g++ AbstractFactory.cpp -o main -g -std=c++11`

**抽象工厂模式总结**   在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。

**优点**  

    1. 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
    2. 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
    3. 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。

**缺点**

    增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”

**适用场景**

    1. 用户无须关心对象的创建过程，将对象的创建和使用解耦
    2. 系统中有多于一个的产品族，而每次只使用其中某一产品族。通过配置文件等方式来使得用户可以动态改变产品族
    3. 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束
    4. 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。

###4. 单例模式
确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。

单例模式有3个要点： 只能有一个实例； 必须自己创建这个实例； 必须自己向整个系统提供这个实例。

**单例模式结构** 。为防止创建多个对象，其构造函数必须是私有的（外界不能访问）。另一方面，为了提供一个全局访问点来访问该唯一实例，单例类提供了一个公有方法getInstance来返回该实例。

[线程安全的单例模式代码实现](single_ton/main.cpp)

####单例模式总结

**优点**:单例模式提供了严格的对唯一实例的创建和访问;单例模式的实现可以节省系统资源
**缺点**:如果某个实例负责多重职责但又必须实例唯一，那单例类的职责过多，这违背了单一职责原则;
多线程下需要考虑线程安全机制;
单例模式没有抽象层，不方便扩展

**适用环境**:系统只需要一个实例对象;某个实例只允许有一个访问接口

###5. 原型模式
使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

- **抽象原型类（AbstractPrototype）**：声明克隆clone自身的接口
- **具体原型类（ConcretePrototype）**：实现clone接口
- **客户端（Client）**：客户端中声明一个抽象原型类，根据客户需求clone具体原型类对象实例

**问题描述** 明天就是周一了，Jungle又陷入了苦恼中，因为作业还没完成。于是Jungle想拿着哥哥Single的作业来抄一份。虽然抄袭作业并不好，但是边抄边学借鉴一下也是可以的。于是乎，Jungle开始动起手来……
![](img/prototype.png)

####原型模式总结
**优点：**

    当创建新的对象实例较为复杂时，原型模式可以简化创建过程，提高创建对象的效率；

    可扩展：模式中提供了抽象原型类，具体原型类可适当扩展；

    创建结构简单：创建工厂即为原型对象本身

**缺点：**

    深克隆代码较为复杂；

    每一个类都得配备一个clone方法，且该方法位于类的内部，修改时违背开闭原则；

**适用环境：**

    当创建新的对象实例较为复杂时，原型模式可以简化创建过程；
    
    结合优点第3条，需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少几个的组合状态，通过复制原型对象得到新实例，比通过使用构造函数创建一个新实例会更加方便。

###6. 建造者模式

##七个结构型模式
###7. 适配器模式

###8. 桥接模式

###9. 组合模式

###10. 装饰模式

###11. 外观模式

###12. 享元模式

###13. 代理模式

##十一个行为型模式
###14. 职责链模式

###15. 命令模式

###16. 解释器模式

###17. 迭代器模式

###18. 中介者模式

###19. 备忘录模式

###20. 观察者模式

###21. 状态模式

###22. 策略模式

###23. 模板方法模式

###24. 访问者模式


